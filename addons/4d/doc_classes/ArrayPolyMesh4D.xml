<?xml version="1.0" encoding="UTF-8" ?>
<class name="ArrayPolyMesh4D" inherits="PolyMesh4D" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../doc/class.xsd">
	<brief_description>
		Custom 4D polyhedral mesh class.
	</brief_description>
	<description>
		ArrayPolyMesh4D is a class for specifying polyhedral meshes with arrays of data, including the vertices, edges, faces, cells, and optional hypervolumes. Unlike the specialized [PolyMesh4D] classes such as [BoxPolyMesh4D], ArrayPolyMesh4D can store any polyhedral mesh, allowing users to create custom meshes with arbitrary data.
		When generating your own polyhedral meshes, keep in mind this order:
		- [method calculate_boundary_normals] needs to be called before [method calculate_seam_faces], because it uses the boundary cell normals.
		- Seams need to be defined, such as with [method calculate_seam_faces], before calling [method collect_cells_in_island], and before [method unwrap_texture_map] if using the [constant UNWRAP_MODE_ISLANDS_FROM_SEAMS] mode, because it uses the seams to determine the islands.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="append_vertex">
			<return type="int" />
			<param index="0" name="vertex" type="Vector4" />
			<param index="1" name="deduplicate_vertices" type="bool" default="true" />
			<description>
				Append a vertex to the polyhedral mesh. If [param deduplicate_vertices] is [code]true[/code] (default), the method will check if the vertex already exists in the [member vertices] array and return the index of the existing vertex. If the vertex does not exist, it will be appended to the vertices array and its index will be returned. In both cases, the returned index points to a vertex identical to the input vertex.
			</description>
		</method>
		<method name="append_vertices">
			<return type="PackedInt32Array" />
			<param index="0" name="vertices" type="PackedVector4Array" />
			<param index="1" name="deduplicate_vertices" type="bool" default="true" />
			<description>
				Append an array of vertices to the polyhedral mesh, by calling [method append_vertex] for each vertex in the input array. The method will return an array of indices, where each index points to a vertex identical to the corresponding vertex in the input array.
			</description>
		</method>
		<method name="calculate_boundary_normals">
			<return type="void" />
			<param index="0" name="normals_mode" type="int" enum="ArrayPolyMesh4D.ComputeNormalsMode" />
			<param index="1" name="keep_existing" type="bool" default="false" />
			<description>
				Calculates the normals of the polyhedral cells. Boundary normals define which side of the cell is the front side, and therefore should be drawn. Boundary normals can also be used to calculate vertex normals to determine how lighting angles are calculated for the cell.
				If [param keep_existing] is [code]true[/code], existing normals are preserved when present, and new normals are only calculated for cells without normals or when the normal vector is zero. If [param keep_existing] is [code]false[/code], all normals are recalculated. It is recommended to keep existing normals when adding new cells to the mesh, and to recalculate all normals when modifying vertex positions or altering the cells.
				[b]Note:[/b] In 3D, normals are determined by the triangle vertex winding order, but in 4D, there is no direct equivalent. Instead, orientation is determined by the relative positions of a representative set of vertices that form a canonical span of 3 basis vectors, with the 4th being calculated to find the normal vector. The direction can either be purely determined by the cell orientation, or forced to point outward from the origin or from the volume of a volumetric hypercell, depending on the selected [param normals_mode]. See [enum ComputeNormalsMode] for details.
			</description>
		</method>
		<method name="calculate_seam_faces">
			<return type="void" />
			<param index="0" name="angle_threshold_radians" type="float" default="0.7853982" />
			<param index="1" name="discard_seams_within_islands" type="bool" default="false" />
			<description>
				Calculates seams automatically by marking each face as a seam when the connected boundary cells have an angle between their cell normals greater than the given angle threshold in radians. Non-boundary cells, such as those between volumes within a volumetric poly mesh, are not considered for seams.
				Before running this function, run [method calculate_boundary_normals] to ensure the cell normals are up to date.
				If [param discard_seams_within_islands] is [code]false[/code], all seams will be kept, only considering the angles, which is faster to calculate (though still not very fast). If [code]true[/code], only seams between disconnected islands of cells are marked, by discarding seams which only appear within islands, keeping only the boundaries between islands. Discarding these intra-island seams produces a cleaner-looking topology, but it is slower to calculate, and may produce worse texture unwrapping results in some cases.
			</description>
		</method>
		<method name="collect_cells_in_island">
			<return type="PackedInt32Array" />
			<param index="0" name="start_cell" type="int" />
			<description>
				Collects all cells in the same island as the starting cell, as an array of cell indices. Cells are considered connected if they share a face that is not marked as a seam, and the island is considered all cells connected to the first, including indirectly through other cells, traversed using a breadth-first search algorithm. The first cell will always be the first item in the returned array.
				Before running this function, ensure that the seams are up to date. You can set seams manually, or calculate seams based on the angles between cells using [method calculate_seam_faces].
			</description>
		</method>
		<method name="merge_with">
			<return type="void" />
			<param index="0" name="other" type="PolyMesh4D" />
			<param index="1" name="offset" type="Vector4" default="Vector4(0, 0, 0, 0)" />
			<param index="2" name="basis" type="Projection" default="Projection(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)" />
			<description>
				Merges this polyhedral mesh with another polyhedral mesh. The other mesh's vertices, edges, faces, cells, and hypervolumes are added to this mesh. The [param offset] and [param basis] parameters are used to transform the other mesh's vertices before adding them to this mesh. This is useful for combining meshes that are in different positions or orientations.
				This method will also attempt to merge the materials of the two meshes, by calling [method Material4D.merge_with] on this mesh's material and passing the other mesh's material as an argument. See [method Material4D.merge_with] for more information.
			</description>
		</method>
		<method name="reconstruct_from_tetra_mesh" qualifiers="static">
			<return type="ArrayPolyMesh4D" />
			<param index="0" name="tetra_mesh" type="TetraMesh4D" />
			<description>
				Reconstructs a polyhedral mesh from a tetrahedral mesh by converting each consecutive sequence of tetrahedral cells with the same starting vertex into a single polyhedral cell, forming a new cell when the starting vertex changes.
				This function is useful for converting tetrahedral meshes into polyhedral meshes when the polyhedral structure is implied by the ordering of the tetrahedral cells and a polyhedral representation is desired for further processing. However, this operation is lossy, and so round-trip conversions may not yield the original data. Whenever possible, always keep the original polyhedral mesh data and work with that directly, and avoid using this function unless absolutely necessary.
			</description>
		</method>
		<method name="set_flat_shading_normals">
			<return type="void" />
			<param index="0" name="normals_mode" type="int" enum="ArrayPolyMesh4D.ComputeNormalsMode" />
			<param index="1" name="recalculate_boundary_normals" type="bool" default="true" />
			<description>
				Sets the polyhedral mesh to use flat shading by setting all vertex instance normals to match their corresponding boundary cell normal. This gives the mesh a faceted appearance, where each polyhedral cell is shaded uniformly.
				If [param recalculate_boundary_normals] is [code]true[/code], the method will first recalculate the boundary normals using [method calculate_boundary_normals] before setting the vertex instance normals.
			</description>
		</method>
		<method name="transform_texture_map">
			<return type="void" />
			<param index="0" name="transform" type="Transform3D" />
			<description>
				Applies a 3D transformation to the UVW texture coordinates of all polyhedral cells in the mesh. The transformation is applied to each vertex instance's UVW coordinates, allowing for operations such as translation, rotation, and scaling of the texture mapping.
				This method is useful for adjusting the texture mapping of the mesh after unwrapping or when modifying the mesh's geometry, ensuring that the texture coordinates remain aligned with the desired appearance.
			</description>
		</method>
		<method name="unwrap_texture_map">
			<return type="void" />
			<param index="0" name="mode" type="int" enum="ArrayPolyMesh4D.UnwrapTextureMapMode" default="3" />
			<param index="1" name="padding" type="float" default="0.0" />
			<param index="2" name="keep_existing" type="bool" default="false" />
			<description>
				Unwraps a texture map for the polyhedral mesh, generating UVW texture coordinates for each vertex instance in each cell. The unwrapping is done based on the selected [param mode], which determines how the unwrapping is performed. See [enum UnwrapTextureMapMode] for details.
				If [param padding] is greater than 0.0, texture islands will have this amount of space between them in texture space, helping to prevent texture bleeding when using mipmaps or other resampling techniques.
				If [param keep_existing] is [code]true[/code], existing texture coordinates are preserved when present, and new texture coordinates are only calculated for cells without texture coordinates. When a new cell is in the same island as an existing cell, the new cell will have its texture coordinates aligned with already mapped cells. When none of the cells in an island have existing texture coordinates, a new island will be mapped. In both cases, the islands will be re-packed with the given [param mode] and [param padding].
			</description>
		</method>
		<method name="unwrap_texture_map_island">
			<return type="void" />
			<param index="0" name="cells_in_island" type="PackedInt32Array" />
			<param index="1" name="keep_existing" type="bool" default="false" />
			<description>
				Unwraps a texture map for a specific island of cells in the polyhedral mesh, generating UVW texture coordinates for each vertex instance in each cell in the island. The island will be rescaled to fill the texture space from (0, 0, 0) to (1, 1, 1), and any repacking needs to be handled afterwards if desired. This function is internally called by [method unwrap_texture_map] when using the [constant UNWRAP_MODE_ISLANDS_FROM_SEAMS] mode.
				The [param cells_in_island] parameter MUST form a continuous connected island of cells, where each consecutive cell shares a non-seam face with at least one of the earlier cells in the array. If the input cells are not consecutively connected by non-seam faces, the function will fail.
			</description>
		</method>
	</methods>
	<members>
		<member name="edge_indices" type="PackedInt32Array" setter="set_edge_indices" getter="get_edge_indices" default="PackedInt32Array()">
			The flat array of edge indices. Every 2 integers defines an edge. Each integer is an index to the [member vertices] array. Integers in this array should not exceed the length of the vertices array, or else the mesh is invalid.
		</member>
		<member name="poly_cell_boundary_normals" type="PackedVector4Array" setter="set_poly_cell_boundary_normals" getter="get_poly_cell_boundary_normals" default="PackedVector4Array()">
			The normals of the polyhedral boundary cells themselves. Boundary normals define which side of the cell is the front side, and therefore should be drawn. Boundary normals can also be used to calculate vertex normals to determine how lighting angles are calculated for the cell. Each Vector4 in this array is for one cell, and should be normalized.
		</member>
		<member name="poly_cell_indices" type="Array[]" setter="set_poly_cell_indices" getter="get_poly_cell_indices" default="[]">
			The hierarchical polyhedral cell indices in the form of an array of arrays of [PackedInt32Array]s. This is the foundational data structure of [PolyMesh4D]. The top level array usually has 2 or 3 items:
			- The first item is an array of 2D faces. It is an array of [PackedInt32Array]s, where each [PackedInt32Array] contains the 1D edge indices that make up one 2D face.
			- The second item is an array of 3D cells. It is an array of [PackedInt32Array]s, where each [PackedInt32Array] contains the 2D face indices that make up one 3D cell.
			- The optional third item is an array of 4D hypervolumes. It is an array of [PackedInt32Array]s, where each [PackedInt32Array] contains the 3D cell indices that make up one 4D hypervolume.
			Since edges are always made of exactly 2 vertices, they are not included in this array. Edges use a simpler data structure where all edges are stored in a single [PackedInt32Array], and every 2 items represent one edge. See [member edge_indices].
		</member>
		<member name="poly_cell_texture_map" type="PackedVector3Array[]" setter="set_poly_cell_texture_map" getter="get_poly_cell_texture_map" default="[]">
			The UVW texture mapping of the polyhedral cells. Each item in this array is a [PackedVector3Array] containing the texture space mapping for the vertex instances of the corresponding cell in the [member poly_cell_indices] array. Each Vector3 in these arrays defines the UVW texture coordinates for the corresponding vertex instance in the cell, and is usually on the range from (0, 0, 0) to (1, 1, 1).
		</member>
		<member name="poly_cell_vertex_normals" type="PackedVector4Array[]" setter="set_poly_cell_vertex_normals" getter="get_poly_cell_vertex_normals" default="[]">
			The normals of the vertex instances for each polyhedral cell. Each item in this array is a [PackedVector4Array] containing the normals for each vertex instance in the corresponding cell in the [member poly_cell_indices] array. Each Vector4 in these arrays should be normalized.
		</member>
		<member name="poly_cell_vertices" type="PackedVector4Array" setter="set_poly_cell_vertices" getter="get_poly_cell_vertices" default="PackedVector4Array()">
			The vertex positions of the polyhedral mesh. Each Vector4 in the array is a position in meters in 4D space. The items in this array are referenced by the [member edge_indices] array.
			[b]Note:[/b] The vertices returned by [method get_vertices] may be longer than this array. This is because [method get_vertices] returns the vertices used for tetrahedralizing the polyhedral mesh, which may include extra virtual vertices added to keep tetrahedral faces aligned with each other. Regardless, the start of the array returned by [method get_vertices] will always match this array, such that it is either a superset of this array, or identical to it.
		</member>
		<member name="seam_face_indices" type="PackedInt32Array" setter="set_seam_face_indices" getter="get_seam_face_indices" default="PackedInt32Array()">
			The indices of the faces marked as seams. Each index is a reference to the items in the faces array, which is the first array in the [member poly_cell_indices] array. Faces are the boundaries of boundary cells, and therefore marking faces as seams affects how islands of cells are determined, such as when calling [method collect_cells_in_island], and when calling [method unwrap_texture_map] if using the [constant UNWRAP_MODE_ISLANDS_FROM_SEAMS] mode.
			[b]Note:[/b] Getting or setting this property is not a trivial operation, because this uses a different data structure in the C++ code, specifically [code]HashSet&lt;int32_t&gt;[/code]. Consider caching the result if you need to read or write the data multiple times.
		</member>
	</members>
	<constants>
		<constant name="COMPUTE_NORMALS_MODE_CELL_ORIENTATION_ONLY" value="0" enum="ComputeNormalsMode">
			When calculating boundary normals, only use the cell orientation to determine the normal direction, preserving the existing orientation of the cells.
		</constant>
		<constant name="COMPUTE_NORMALS_MODE_FORCE_OUTWARD_OVERRIDE_CELL_ORIENTATION" value="2" enum="ComputeNormalsMode">
			When calculating boundary normals, force the normals to point outward, overriding the existing orientation of the cells. When a cell is part of a volumetric hypercell, the normal will point outward from the volume, otherwise the normal will point away from the origin.
		</constant>
		<constant name="COMPUTE_NORMALS_MODE_FORCE_OUTWARD_FIX_CELL_ORIENTATION" value="1" enum="ComputeNormalsMode">
			When calculating boundary normals, force the normals to point outward, and adjust the orientation of the cells to match. When a cell is part of a volumetric hypercell, the normal will point outward from the volume, otherwise the normal will point away from the origin. Fixing the cell orientation involves swapping the "winding order" of the cell by swapping the first two faces of the cell.
		</constant>
		<constant name="UNWRAP_MODE_AUTOMATIC" value="0" enum="UnwrapTextureMapMode">
			Automatically choose the best unwrapping mode. If a mesh has seams defined, use [constant UNWRAP_MODE_ISLANDS_FROM_SEAMS], otherwise use [constant UNWRAP_MODE_TILE_CELLS].
		</constant>
		<constant name="UNWRAP_MODE_EACH_CELL_FILLS" value="1" enum="UnwrapTextureMapMode">
			Each cell is unwrapped to fill the entire UVW space from (0, 0, 0) to (1, 1, 1). This is useful for objects where all faces should have the same texture, such as a tiled pattern, like a block of cobblestone in Minecraft.
		</constant>
		<constant name="UNWRAP_MODE_TILE_CELLS" value="2" enum="UnwrapTextureMapMode">
			Each cell is unwrapped to fit within a tile in the UVW space. The tiles are arranged in a grid that fits within the UVW space from (0, 0, 0) to (1, 1, 1), where the space each tile takes up is proportional to the inverse cube root of the number of cells. For example, if there are 8 cells, the tiles will be arranged in a 2x2x2 grid, with each tile taking up 0.5 units in each dimension.
		</constant>
		<constant name="UNWRAP_MODE_ISLANDS_FROM_SEAMS" value="3" enum="UnwrapTextureMapMode">
			Each island of connected cells, separated by seams, is unwrapped to fit within a tile in the UVW space. The tiles are arranged in a grid that fits within the UVW space from (0, 0, 0) to (1, 1, 1), where the space each tile takes up is proportional to the inverse cube root of the number of islands. For example, if there are 8 islands, the tiles will be arranged in a 2x2x2 grid, with each tile taking up 0.5 units in each dimension.
		</constant>
	</constants>
</class>
